
Maana Q

 

 

 

 

 

Knowledge Technology Development Guide

 

 

Table of Contents

[Introduction.. 4](#_Toc521325681)

[Welcome to Maana.. 4](#_Toc521325682)

[Better and Faster. 4](#_Toc521325683)

[Scope. 4](#_Toc521325684)

[Glossary. 4](#_Toc521325685)

[The Maana Platform.. 4](#_Toc521325686)

[The Computational Knowledge Graph (CKG) 5](#_Toc521325687)

[Utilizing GraphQL. 5](#_Toc521325688)

[Maana Platform Architecture and GraphQL. 5](#_Toc521325689)

[Computational Knowledge Graph Features. 6](#_Toc521325690)

[Data Model Split. 7](#_Toc521325691)

[Knowledge Microservices. 7](#_Toc521325692)

[Bots, Bot Actions, Kinds and Services. 8](#_Toc521325693)

[Event Handling.. 8](#_Toc521325694)

[Queries and Mutations. 9](#_Toc521325695)

[Kinds and Services. 9](#_Toc521325696)

[Development. 10](#_Toc521325697)

[Design Stage. 10](#_Toc521325698)

[Focus on the GraphQL. 10](#_Toc521325699)

[Local Service Stage (Standalone) 10](#_Toc521325700)

[Local Service (Maana) 12](#_Toc521325701)

[Stage: Unmanaged Service.. 13](#_Toc521325702)

[1.1.       MAANA catalogue. 13](#_Toc521325703)

[2.     Defining a model in Maana. 14](#_Toc521325704)

[3.     Hydrating the model with data. 15](#_Toc521325705)

[4.     Querying a model 18](#_Toc521325706)

[4.1.       Query through service end points. 18](#_Toc521325707)

[4.2.       Query using global entry points. 18](#_Toc521325708)

[4.3.       Query using allinstances. 19](#_Toc521325709)

[4.4.       Query across kinds. 20](#_Toc521325710)

[5.     Developing knowledge microservices. 21](#_Toc521325711)

[5.1.       Project Setup. 21](#_Toc521325712)

[5.2.       Development. 22](#_Toc521325713)

[5.3.       Packaging.. 22](#_Toc521325714)

[5.4.       Adding a knowledge microservice to the MAANA catalogue. 22](#_Toc521325715)

[6.     Developing knowledge applications. 23](#_Toc521325716)

[7.     Glossary of Terms. 23](#_Toc521325717)

[8.     Troubleshooting. 23](#_Toc521325718)

 

 

 

 

Introduction
============

Welcome to Maana
----------------

Maana was founded with the vision of using technology to systematize the world’s industrial expertise and data into digital knowledge that could significantly advance the global economy.  Our mission is to facilitate the tens of millions of experts working in industrial companies around the world, and give them the ability to make better decisions, faster.  We are devoted to putting the power of artificial intelligence (AI) into the hands of millions of industry experts, offering enhanced decision-making tools in a rapid response environment.

Better and Faster
-----------------

In 2013 Maana invented a new way to represent industrial knowledge mathematically, using the Maana Patented Computational Knowledge Graph™.  This unique technology enables industrial companies to encode human expertise and data from across silos into digital knowledge, eliminating the need to move data and enabling the creation of thousands of models at scale, through the re-usability of models across the enterprise.

Scope
-----

This guide is intended for the use of Solution Developers and Data Scientists, and describes how to develop such services (aka "bots") and applications and operationalize them in a production setting.

Glossary
--------

Prior to working with the Maana Platform, it is suggested that you familiarize yourself with some basic terms and concepts that will help the make most out of your Maana portal experience.  For a complete [Glossary of Terms](#Glossary%20of%20Terms), please refer to the Appendix found at the back of this document.

The Maana Platform
==================

The Maana platform is used by solutions teams to deliver knowledge applications to their end users (i.e., business users, SMEs, managers).  This “solution team” approach involves the collaboration of analysts, engineers, and data scientists.  The platform is designed to build an enterprise-wide knowledge layer, utilizing search and exploration for solution development and delivery.

### The Computational Knowledge Graph (CKG)

At the core of any Maana solution sits our Computational Knowledge Graph (CKG), a network of models built using machine learning techniques and artificial intelligence that powers AI-driven applications used to digitize decision support and operations.  It allows the knowledge of the business to be incrementally captured and grown, evolving and becoming increasingly sophisticated as more projects are developed.

Utilizing GraphQL
-----------------

Maana uses GraphQL to represent and expose its Computational Knowledge Graph.  GraphQL is a data query language created by Facebook and open-sourced in 2015 as an alternative to REST interfaces.

 

GraphQL provides a complete and understandable description of the data in the API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.  With the GraphQL type system, the developers can access the full capabilities of your data from a single endpoint.

 

GraphQL creates a uniform API across your entire application without being limited by a specific storage engine.  The developer provides functions for each field in the type system, and GraphQL calls them with optimal concurrency.

### Maana Platform Architecture and GraphQL

![](file:////Users/robertray/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png)

For more information on using on Graph QL, please refer to the link provided below:

·       [How to GraphQL](https://www.howtographql.com/)

Computational Knowledge Graph Features
--------------------------------------

With the Computational Knowledge Graph:

·      The Graph is dynamic.  Nodes, which represent concepts in the graph, are not static containers, but rather act as computational vessels, allowing algorithms to be stored and executed.

·      Reusable Models - Knowledge Graph flexibility enables groups across the organization to leverage and build-upon models created by other groups, dramatically accelerating the speed at which models are created throughout the organization.  These models are dynamic, and once operationalized into applications, they learn and adapt based on the user behaviors and provide continuous intelligence for day-to-day operations.

·      The structure of data is separated from its content.  This separation enables a fluidity of modeling - data from any source or format can be seamlessly integrated, modeled, searched, analyzed, operationalized and re-purposed.

·      Data remains at the source - Only the most relevant data, within the context of what is being optimized, is indexed and brought into the graph.

·      Each resulting Data Model is a unique combination of three key components, which are instrumental in optimizing assets and decision flows:

1.     Subject Matter Expertise

2.     Relevant Data from Silos

3.     The Right Algorithm

 

**Note**:  These algorithms could be as simple as pulling in new data from an external source, to as complicated as classification of documents through machine learning. 

 

·      As source data is updated in real time, so are the nodes and the computational models that act on that data, permitting more complex relationships to be modeled, and enhancing the graph’s ability to understand the connections between concepts (rather than simple strings of data), and encouraging optimization of decisions and operations.

 

The CKG consists of **concepts** and **properties**, **instances** and **values**, and **relations** and **links**.

 

Consider the concept of a *ContainerShip* with the properties of *name*, *length*, *position*, etc.  A specific instance (entity) for our ContainerShip might have values for each of these properties, such as the vessel Maersk Viking having a length of *400 meters*.  Such properties can be scalar (e.g., numbers, strings, dates) or might refer to other concepts/instances - such as the *Hold Cargo* of the vessel.

 

In some cases, property values for an instance may simply be stored, as they are rarely subject to change.  In other cases, they will be dynamically computed, due to constantly changing values - such as a ship's *weight* (which is dependent upon its cargo) or variables like the vessel’s *current position* (which requires getting a GPS reading).

 

Unlike a traditional graph database, Maana incorporates arbitrary computation (through custom GraphQL resolvers) and distributes the graph into subgraphs managed by different microservices, optionally with their own dedicated persistence mechanism.  This separation enables a fluidity of modeling, allowing data from any source and in any format to be seamlessly integrated, modeled, searched, analyzed, operationalized and re-purposed.  It also places more responsibility on the microservices to provide their own storage.

### Data Model Split

To address this, Maana proposes an explicit split between the data models (i.e., GraphQL type definitions) that a service uses and its operations (i.e., GraphQL resolvers).  Maana will generate the appropriate managed service for such models using KindDB, Prisma, neo4j, etc.  With this, the solution developer only provides the logic they care about and let the system take care of all the CRUD/ORM-like operations on the data.

Knowledge Microservices
=======================

Knowledge microservices are a class of GraphQL services that are developed for the Maana platform.  Unlike pure client-server or n-tier architectures, Maana's microservices act as peers in an asynchronous and loosely-coupled arrangement that promotes independent scaling and extensibility.  They provide identity and access controls, graph persistence, search, machine learning, and natural language processing.

 

As a consequence, these peer microservices provide reasoning capabilities to Knowledge Applications, which help solve domain-specific problems and support optimal decision-making that is capable of learning over time.  Taken together, these services allow the solution developer to focus on designing GraphQL schemas and implementing computational resolvers only where needed.

 

The Maana platform manages these services, providing authentication, reliable messaging, (automatic) graph persistence (with search and querying), scaling, monitoring, and a rich UX.  These GraphQL services include:

-   authenticated access

-   client/server boilerplate

-   reliable messaging using RabbitMQ

-   lifecycle management (info, register, deregister)

-   Docker containerization and automatic scaling/load balancing

 

Maana Knowledge Services form a network of GraphQL endpoints, exposing their types, queries, and mutations for direct access, as well as publishing and subscribing to network events.  A GraphQL service  (or endpoint) consists of:

-   types

-   queries

-   mutations

-   events (pub/sub)

 

Examples of knowledge microservices include:

 

** Indexers**

** Miners**

** Classifiers**

• Text • Number • Time • Geospatial • Geometric

• Statistics • Probabilities • NER/NLP

• Entity • Field • Document • Image

Bots, Bot Actions, Kinds and Services
-------------------------------------

A **Bot** is a Knowledge Microservice that “listens” for specific events on a system bus, and acts automatically when such events happen to mine and enrich the graph.  They provide specialized queries and mutations that perform [BotActions](https://confluence.corp.maana.io/display/RD/Bot+Actions), allowing the bot to provide asynchronous status updates.

 

**Example**:  When a raw data file is loaded into MAANA, a bot automatically analyzes it to identify mentions of entities like persons, phone numbers, values, and facts.

 

Users can configure, start, stop, and schedule bot actions.  This enables user interface components to immediately return the latest status:

-   Throughout the duration of extended, ongoing operations.

-   By events that act as automatic triggers  (such as entity recognition, new concept creation and classification).

-   Report any errors or messages.

 

There are two primary scenarios to consider here:

1.  Event Handling

2.  Direct Query/Mutations

### Event Handling

When a Knowledge Service subscribes to and handles an event, such as "fileAdded," it can (optionally) create an instance of a BotAction Kind by mutating the Computational Knowledge Graph.

 

**Note**:  As the service performs its operation, it can periodically update the progress (if it is deterministic) and update the status and report errors.

 

### Queries and Mutations

A user can invoke a query or mutation either explicitly (e.g., train a classifier on labeled data) or implicitly (i.e., as part of query graph).  In such cases, the service exposes such queries and mutations as returning a BotAction.

### Kinds and Services

All Kinds (concepts, types) are associated with a service.  This service is said to provide the (entities of) the Kind.  Many Kinds are purely extensional (i.e., data) and do not have custom CRUD behavior.  These Kinds are automatically managed by the Computational Knowledge Graph (CKG) and stored in the KindDB, where they are indexed for efficient search and querying (including sophisticated entity concurrences).

 

Services also depend on existing Kinds and queries, mutations, and events.  The services that provide these Kinds (which may be fully managed by CKG/KindDB) can be imported into a new service purely through GraphQL and specified in a manifest that is used to create and register a new service.  This process will result in a merged schema on a service-specific endpoint that the newly developed service uses for *all* Maana GraphQL communication (non-pub/sub).

Development
===========

The development of a Maana Knowledge Application solution can be best described in five stages:

1.  Design

2.  Local Service (Standalone)

3.  Local Service (Maana)

4.  Unmanaged Service

5.  Managed Service

Design Stage
------------

The primary focus of this stage is:

-   GraphQL types (Kinds, Properties, Relations)

-   Queries and Mutations (often based on Problem Questions) 

-   Events (consumed and produced)

 

At the Design Stage, the overall problem to be solved has been analyzed and a domain model and set of *decomposed* problem questions has been generated.  Some discussion of entity sources and data science has taken place, and it is now time to code one or more Knowledge Microservices to provide some new concepts (Types, Kinds) along with Queries, Mutations, and Events that involve them.

### Focus on the GraphQL

For the Knowledge Service/Bot, this is the entire description of and interface to their world.  Define a file in the GraphQL SDL, such as `model.gql`, and include custom queries, mutations, and publications/subscriptions.

-   Plan the custom resolvers.

-   Consider such things as the nature of their core logic.

Local Service Stage (Standalone)
--------------------------------

The primary focus of this stage is:

-   Selecting the programming language

-   Identifying dependencies - Libraries, existing services and domain models (often based on Problem Questions).

-   Core Logic – Used to satisfy GraphQL interface contract.

 

With at least an initial design complete, the following implementation decisions must be made:

-   Are there existing Kinds and Services that can be reused?

-   Are their existing code libraries or ML models that can be reused?

-   What is the best programming language for this task?

-   Is there reference data or domain data?

-   Are there long-running tasks?

-   What is the scale, performance and capacity factors?

 

Once a programming language is chosen, then an [existing project template](https://github.com/maana-io/Q-ksvc-templates) can be used to scaffold a new Knowledge Microservice/Bot in Scala/JVM, Python, JavaScript, etc.

 

**Note**:  The development of core logic, or a machine learning solution occurs (as it normally should):  writing, testing, and debugging code or improving model accuracy.

 

The Knowledge Service is a standard GraphQL endpoint, which can be run and tested within the development environment, and used via [Maana CLI](https://www.npmjs.com/package/graphql-cli-maana), its own exposed [GraphiQL](https://github.com/graphql/graphiql), a standalone [GraphQL Playground](https://github.com/prismagraphql/graphql-playground), etc.

Dependent types and services are **imported** into the service **model** using a modified version of a technique from [graphql-import](https://github.com/prismagraphql/graphql-import), as shown below.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# import File, Url, MimeType from io.maana.core @PASSTHRU
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
input CrawlOptions {
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  url: Url
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type Mutation {
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  crawl(input: CrawlOptions): BotAction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

Local Service Stage (Maana)
---------------------------

The primary focus of this stage is:

-   Continue Local development.

-   Connect to a remote Maana deployment (e.g., Azure) to consume and produce GraphQL other services via your custom endpoint.

 

In the previous Standalone stage, it is likely that various calls/services were stubbed or mocked because they required accessing a Maana cluster.  In this stage, it is time to interact with a Maana deployment, typically one dedicated to development.

Communication to a Maana system requires the use of authentication.

 

**Note**:  This is configured differently, based on the language/framework being used.  Refer to the project template documentation used to scaffold the Knowledge Service project.

 

The service being development must be registered with Maana.  This is typically done programmatically using the Maana CLI by specifying a manifest that describes the service and its dependencies, as shown below:

 

`{   id: "io.maana.azure.crawler",   name: "Maana   Azure Storage Crawler Service",   dockerRegistry: null,   hostedUrl: null, }`

 

Registering a new service with Maana will cause CKG to generate a dedicated service endpoint, such as <https://knowledge.acme.com/service/io.maana.azure.crawler:7331.>

 

This dedicated service endpoint enables the standalone service to communicate to Maana, but does not allow Maana to dispatch calls to the standalone service due to network connectivity restrictions (this will be resolved in the next stages).

 

The full GraphQL schema for a service manifest is:

 

`# from io.maana.system type ServiceManifest {   id: ID!   name: String   description: Text   registeredOn:   DateTime   registeredBy:   User   dockerRegistry:   Url   hostedUrl: Url   modelSdl: String }`

Unmanaged Service Stage
-----------------------

The primary focus of this stage is:

-   To deploy your service via your own means (e.g., Heroku).

-   Make it accessible to Maana to communicate to for call and event dispatching.

 

When it is time to have full participation in the Maana processing network (having its endpoint services consumed by other services, user interfaces, or automatically based on event subscription), then Maana's Concept Knowledge Graph (CKG) must be able to communicate to the service.

 

The service must be deployed to a host that is accessible from the Maana cluster (e.g., Heroku, Azure, AWS), on-premise.  In this configuration, the service owner is responsible for all aspects of the service, since Maana only has knowledge of a GraphQL endpoint URL and the schema it provides.

See the [Deploy to Heroku tutorial](https://confluence.corp.maana.io/display/RD/Training).

Managed Service Stage
---------------------

The primary focus of this stage is to “Dockerize” your service, and make it available in a registry that Maana has access to (e.g., Azure).

 

Maana can completely manage a containerized Knowledge M  icroservice/Bot, by specifying a Docker registry that the Maana deployment has access to (e.g., DockerHub, Azure).

 

The following additional information is required when configuring a service to be managed by Maana:

-   scale stuff??

-   ?? [Andrey Batyuk](https://confluence.corp.maana.io/display/~andrey)

 

 

Debugging a Knowledge Microservice
==================================

?? [Andrey Batyuk](https://confluence.corp.maana.io/display/~andrey)

 

 
